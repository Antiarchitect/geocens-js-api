{"name":"Geocens-js-api","tagline":"GeoCENS JavaScript API for Sensor Data Access and Visualization","body":"# GeoCENS JavaScript API\r\n\r\nThe GeoCENS JavaScript API can be used to retrieve geospatial sensor data from either the GeoCENS Data Service or OGC SOS compatible services, and display the information on a map or chart.\r\n\r\n## Requirements\r\n\r\n* jQuery 1.10.1 or newer\r\n\r\n## Installation\r\n\r\nFor a web page, include the `geocens.js` file in a script tag:\r\n\r\n\t<script src=\"javascripts/geocens.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\r\n\r\n### Alternate Install for Rails\r\n\r\nFor use with the Rails asset pipeline, try the [geocens-js-api-rails](https://github.com/Canarie-Sensor-RPI/geocens-js-api-rails) gem.\r\n\r\n## Getting Started\r\n\r\nHere is a brief introduction on how to retrieve data from the GeoCENS Data Service, with an API Key. If you do not already have a key, please contact us at <info@geocens.ca> or use the JS API to load data from an OGC SOS compatible service. An [interactive demo is available in the `demo` directory](http://canarie-sensor-rpi.github.io/geocens-js-api/demo.html), and the API Key from there can be used here.\r\n\r\nIn this example, we will go from an API Key to retrieving a time series for a Datastream. A Datastream is a set of data returned for a single observed property on a sensor.\r\n\r\nFirst, we connect to the Data Service and download a list of sensors:\r\n\r\n\tGeocens.DataService.getSensors({\r\n\t\tapi_key: api_key,\r\n\t\tdone: function (sensors) {\r\n\t\t\twindow.sensor = sensors[0];\r\n\t\t}\r\n\t});\r\n\r\nThis provides us with a `Sensor` object in the `done` callback. We can retrieve properties for the Sensor:\r\n\r\n\tsensor.metadata;\r\n\r\nWhich returns an object with the properties:\r\n\r\n\t{\r\n\t\t\"id\": \"5C-86-4A-00-2C-9E\",\r\n\t\t\"user\": \"jamesbadger@gmail.com\",\r\n\t\t\"uid\": \"4ddecd5124661f9442cfca8be23f8dda\",\r\n\t\t\"altitude\": 1100,\r\n\t\t\"samplingrate\": 0,\r\n\t\t\"loc\": [\r\n\t\t\t51,\r\n\t\t\t-114\r\n\t\t],\r\n\t\t\"title\": \"Our first integration Testing\",\r\n\t\t\"height\": 0,\r\n\t\t\"nickName\": \"Alpha\",\r\n\t\t\"description\": \"\",\r\n\t\t\"last_time_online\": \"2012-09-18T21:04:40\",\r\n\t\t\"phens\": [\r\n\t\t\t\"airtemperature\",\r\n\t\t\t\"relatedhumidity\",\r\n\t\t\t\"airquality\",\r\n\t\t\t\"hydrogentest\",\r\n\t\t\t\"hydrogentest1Name\"\r\n\t\t]\r\n\t}\r\n\r\nWe can also use the Sensor object to retrieve the list of datastreams:\r\n\r\n\tsensor.getDatastreams({\r\n\t\tdone: function (datastreams) {\r\n\t\t\t\twindow.datastream = datastreams[0];\r\n\t\t}\r\n\t});\r\n\r\nWith this `Datastream` object, we can now retrieve the time series data:\r\n\r\n\tdatastream.getTimeSeries({\r\n\t\tdone: function (seriesData) {\r\n\t\t\t\twindow.seriesData = seriesData;\r\n\t\t}\r\n\t});\r\n\r\nBy default, `getTimeSeries()` will retrieve 24 hours of observation values from the Data Service.\r\n\r\nThe `getTimeSeries()` method will cache the results in the Datastream object, and return an array of objects:\r\n\r\n\t[{\r\n\t\ttimestamp: 1356998400000,\r\n\t\tvalue: 3.88\r\n\t},\r\n\t{\r\n\t\ttimestamp: 1369699200000,\r\n\t\tvalue: 5.22\r\n\t}]\r\n\r\nThe returned objects contain timestamp and value properties. The timestamps correspond to the number of milliseconds since January 1, 1970, 00:00:00 UTC. They can be parsed with JavaScript's built-in Date library: `new Date(1356998400000)`.\r\n\r\nAfterwards, the GeoCENS Map and GeoCENS Chart modules can be used to visualize the sensor and datastreams.\r\n\r\n## Usage\r\n\r\n#### Geocens.noConflict\r\n\r\nIf you are using a variable that already is called `Geocens`, you can prevent the GeoCENS JS API from overwriting it. The `noConflict()` method will return the `Geocens` variable back to the previous owner/value.\r\n\r\n\tvar GeocensAPI = Geocens.noConflict();\r\n\tvar sosSource = GeocensAPI.SOS({â€¦});\r\n\r\n### Loading Data\r\n\r\nThe library can load data from either an [OGC SOS compatible service](http://www.opengeospatial.org/standards/sos), or from our GeoCENS Data Service.\r\n\r\n#### Geocens.SOS\r\n\r\nDefine an OGC SOS object with the SOS URL:\r\n\r\n\tvar sosSource = new Geocens.SOS({\r\n\t\tservice_url: \"http://www.example.com/sos\"\r\n\t});\r\n\r\nThis object can be reused to use the same `service_url` for multiple `getObservation` invocations.\r\n\r\n#### Geocens.SOS.getObservation\r\n\r\nUse an OGC SOS object to retrieve SOS observation data, as set out by the [Observation and Measurement specification](http://www.opengeospatial.org/standards/om). Results returned are procedure-observation pairs that exist within the filter criteria. Procedures that have no data within the filter will not be returned. Results are filtered by SOS Offering (required), Observed Property (required), and bounding box (optional).\r\n\r\n\tsosSource.getObservation({\r\n\t\toffering: \"sos_offering\",\r\n\t\tproperty: \"sos_property\",\r\n\t\tnorthwest: [51, -114],\r\n\t\tsoutheast: [-51, 114],\r\n\t\tdone: function (observations) {\r\n\t\t\twindow.observations = observations;\r\n\t\t}\r\n\t});\r\n\r\nThese can be combined:\r\n\r\n\tGeocens.SOS.getObservation({\r\n\t\tservice_url: \"http://www.example.com/sos\",\r\n\t\toffering: \"sos_offering\",\r\n\t\tproperty: \"sos_property\",\r\n\t\tnorthwest: [51, -114],\r\n\t\tsoutheast: [-51, 114],\r\n\t\tdone: function (observations) {\r\n\t\t\twindow.observations = observations;\r\n\t\t}\r\n\t});\r\n\r\n##### option: offering\r\n\r\nThe SOS Offering key. Can be used to filter into a logical group of observations. Is required.\r\n\r\n##### option: property\r\n\r\nThe SOS Observed Property key. Can be used to filter observations by physical phenomena. Note that it is typically a [URN](http://en.wikipedia.org/wiki/Uniform_resource_name). Is required.\r\n\r\n##### option: northwest\r\n\r\nAn optional pair of Float numbers representing the North West corner of the bounding box. Used in conjunction with `southeast`. Only observations inside the bounding box will be returned. Defaults to [90, -180] which is 90 degrees North, and 180 degrees West.\r\n\r\n##### option: southeast\r\n\r\nAn optional pair of Float numbers representing the South East corner of the bounding box. Used in conjunction with `northwest`. Only observations inside the bounding box will be returned. Defaults to [-90, 180] which is 90 degrees South, and 180 degrees East.\r\n\r\nIf both `northwest` and `southeast` are not provided, then the bounding box will encompass the entire world.\r\n\r\n##### option: done\r\n\r\nAn optional callback function that will return an array of Observation objects as the first parameter.\r\n\r\n#### Observation.attributes\r\n\r\nWith an Observation object, the basic metadata properties can be retrieved:\r\n\r\n\tobservation.attributes();\r\n\r\nExample attributes for an observation from an OGC SOS:\r\n\r\n\t{\r\n\t\tlatitude: 51.000,\r\n\t\tlongitude: -114.000,\r\n\t\toffering: \"temperature\",\r\n\t\tproperty: \"urn:ogc:def:property:noaa:ndbc:water temperature\",\r\n\t\tsensor_id: \"snr_301\",\r\n\t\tsensor_type: \"SOS\",\r\n\t\tservice_url: \"http://example.com/sos\",\r\n\t\tunit: \"celcius\"\r\n\t}\r\n\r\n#### Observation.describe\r\n\r\nFor Observations, the [sensorML document](http://www.opengeospatial.org/standards/sensorml) can be retrieved for additional metadata. It is then possible to use [jQuery's traversal API](http://api.jquery.com/category/traversing/) to navigate the result.\r\n\r\n\tobservation.describe({\r\n\t\tdone: function (sensorML) {\r\n\t\t\tvar intendedApp = sensorML.find(\"classifier[name~='intendedApplication']\").text();\r\n\t\t\t// \"water temperature monitoring\"\r\n\t\t}\r\n\t});\r\n\r\nNote that the sensorML document may or may not include the `classifier` element; it is up to the user to determine useful data from the sensorML document.\r\n\r\n#### Observation.getTimeSeries\r\n\r\nThe time series records can be retrieved:\r\n\r\n\tobservation.getTimeSeries({\r\n\t\tstart: new Date(\"2013-01-01 00:00:00Z\"),\r\n\t\tend:   new Date(\"2013-05-28 00:00:00Z\"),\r\n\t\tdone:  function (seriesData) {\r\n\t\t\twindow.seriesData = seriesData;\r\n\t\t}\r\n\t});\r\n\r\n##### option: start\r\n\r\nAn optional Date object specifying the start limit of the time series.\r\n\r\n##### option: end\r\n\r\nAn optional Date object specifying the end limit of the time series.\r\n\r\n##### option: done\r\n\r\nAn optional callback function that will return an array of Time Series objects as the first parameter. Example response:\r\n\r\n\t[{\r\n\t\ttimestamp: 1356998400000,\r\n\t\tvalue: 3.88\r\n\t},\r\n\t{\r\n\t\ttimestamp: 1369699200000,\r\n\t\tvalue: 5.22\r\n\t}]\r\n\r\n#### Observation.seriesData\r\n\r\nRetrieve a sorted array of timeseries objects for an SOS Observation, based on data already retrieved by `getTimeSeries()` operations. If `getTimeSeries()` has not yet been called, `seriesData()` will return an empty array.\r\n\r\n\r\n#### Translation Engine Customization\r\n\r\nThe Translation Engine URL is hard-coded into the library. It is a GeoCENS proxy service that retrieves data from OGC SOS and provides easily-consumed data. Users can optionally override it:\r\n\r\n\tGeocens.TranslationEngine.setPath(\"http://example.com/translation-engine/\");\r\n\r\nAfter override, all new requests will use the new Translation Engine path.\r\n\r\n#### Geocens.DataService\r\n\r\nDefine a Data Service object with your Data Service API key:\r\n\r\n\tvar dsSource = new Geocens.DataService({\r\n\t\tapi_key: \"your_32_character_api_key\"\r\n\t});\r\n\r\n#### Geocens.DataService.getSensors\r\n\r\nAn API Key gives access to certain sensors for a user in the GeoCENS Data Service. This method can be used to get a list of sensors for an API Key.\r\n\r\n\tdsSource.getSensors({\r\n\t\tdone: function (sensors) {\r\n\t\t\twindow.sensors = sensors;\r\n\t\t},\r\n\r\n\t\traw: function (data) {\r\n\t\t\twindow.sensorsJSON = data;\r\n\t\t}\r\n\t});\r\n\r\nWhen the sensors have been retrieved from the server, the `done` callback will be called. The `sensors` parameter will contain an array of zero or more Sensor objects. From there, each of the Sensor objects can be used to load their datastreams or metadata.\r\n\r\nAlternatively or simultaneously the `raw` callback can be used to receive the JS objects from the GeoCENS Data Service not formatted as Sensor objects.\r\n\r\n#### Geocens.DataService.getSensor\r\n\r\nUse a Data Service object to retrieve a single sensor with its sensor ID:\r\n\r\n\tdsSource.getSensor({\r\n\t\tsensor_id: \"32_character_sensor_id\",\r\n\t\tdone: function (sensor) {\r\n\t\t\twindow.sensor = sensor;\r\n\t\t}\r\n\t});\r\n\r\nThese can be combined:\r\n\r\n\tGeocens.DataService.getSensor({\r\n\t\tapi_key: \"your_32_character_api_key\",\r\n\t\tsensor_id: \"32_character_sensor_id\",\r\n\t\tdone: function (sensor) {\r\n\t\t\twindow.sensor = sensor;\r\n\t\t}\r\n\t});\r\n\r\nThe `done` option will return the Sensor object as the first parameter after the metadata has been retrieved.\r\n\r\n#### Sensor.metadata\r\n\r\nWith a Sensor object, the basic metadata properties can be retrieved:\r\n\r\n\tsensor.metadata;\r\n\r\nExample attributes for a sensor from GeoCENS Data Service:\r\n\r\n\t{\r\n\t\tid: \"radio-1\",\r\n\t\tuid: \"2c8df396cf668a78b643ccf6ed7a5947\",\r\n\t\ttitle: \"Demonstration Sensor Radio-1\",\r\n\t\tcontact_email: \"james@geocens.ca\",\r\n\t\tdescription: \"lorem ipsum\",\r\n\t\tcontact_name: \"James Badger\",\r\n\t\tloc: [\r\n\t\t\t51.08125,\r\n\t\t\t-114.13412\r\n\t\t],\r\n\t\tuser: \"demo@geocens.ca\",\r\n\t\tphens: [\r\n\t\t\t\"airquality\"\r\n\t\t]\r\n\t}\r\n\r\n#### Sensor.getDatastreams\r\n\r\nWith a Sensor object, an array of Datastream objects for that sensor can be retrieved:\r\n\r\n\tsensor.getDatastreams({\r\n\t\tdone: function (datastreams) {\r\n\t\t\twindow.datastreams = datastreams;\r\n\t\t},\r\n\r\n\t\traw: function (data) {\r\n\t\t\twindow.datastreamJSON = data;\r\n\t\t}\r\n\t});\r\n\r\nWhen the datastreams have been retrieved from the server, the `done` callback will be called. The `datastreams` parameter will contain an array of zero or more Datastream objects. From there, each of the Datastream objects can be used to load their time series or attributes.\r\n\r\nAlternatively or simultaneously the `raw` callback can be used to receive the JS objects from the GeoCENS Data Service not formatted as Datastream objects.\r\n\r\n#### Sensor.datastreams\r\n\r\nReturn an array of Datastream objects for this Sensor. If the datastreams for this sensor have not been downloaded from GeoCENS using `Sensor.getDatastreams()`, then `null` will be returned. If the datastream sensors have been downloaded, then an array of datastreams will be returned. If the datastream information for the sensor has been retrieved and there are no datastreams for this sensor, then an empty array will be returned.\r\n\r\nExample usage:\r\n\r\n\tvar streamsList = sensor.datastreams;\r\n\r\n#### Geocens.DataService.getDatastream\r\n\r\nUse a Data Service object to retrieve a singular datastream with its sensor ID and datastream ID:\r\n\r\n\tdsSource.getDatastream({\r\n\t\tsensor_id: \"32_character_sensor_id\",\r\n\t\tdatastream_id: \"32_character_datastream_id\",\r\n\t\tdone: function (datastream) {\r\n\t\t\twindow.datastream = datastream;\r\n\t\t}\r\n\t});\r\n\r\nThese can be combined:\r\n\r\n\tGeocens.DataService.getDatastream({\r\n\t\tapi_key: \"your_32_character_api_key\",\r\n\t\tsensor_id: \"32_character_sensor_id\",\r\n\t\tdatastream_id: \"32_character_datastream_id\",\r\n\t\tdone: function (datastream) {\r\n\t\t\twindow.datastream = datastream;\r\n\t\t}\r\n\t});\r\n\r\nThe `done` option will return the Datastream object as the first parameter after the metadata has been retrieved.\r\n\r\n#### Datastream.attributes\r\n\r\nWith a Datastream object, the basic metadata properties can be retrieved:\r\n\r\n\tdatastream.attributes();\r\n\r\nExample attributes for a datastream from GeoCENS Data Service:\r\n\r\n\t{\r\n\t\tuid: \"ccc92c6fe57dff592ff687d99c4ebf70\",\r\n\t\tid: \"carbonMonoxide\",\r\n\t\tsensor: {\r\n\t\t\tid: \"5C-86-4A-00-2C-9E\",\r\n\t\t\tuser: \"bob@example.com\",\r\n\t\t\tuid: \"4ddecd5124661f9442cfca8be23f8dda\",\r\n\t\t\taltitude: 1100,\r\n\t\t\tsamplingrate: 0,\r\n\t\t\tloc: [51,-114],\r\n\t\t\ttitle: \"Our first integration Testing\",\r\n\t\t\theight: 0,\r\n\t\t\tnickName: \"Alpha\",\r\n\t\t\tdescription: \"\",\r\n\t\t\tlast_time_online: \"2012-09-18T21:04:40\",\r\n\t\t\tphens: [\r\n\t\t\t\t\"airtemperature\",\r\n\t\t\t\t\"relatedhumidity\",\r\n\t\t\t\t\"airquality\",\r\n\t\t\t\t\"hydrogentest\",\r\n\t\t\t\t\"hydrogentest1Name\"\r\n\t\t\t]\r\n\t\t},\r\n\t\tunit: \"ppm\",\r\n\t\tphenName: \"airquality\",\r\n\t\tuser: \"bob@example.com\"\r\n\t}\r\n\r\n#### Datastream.getTimeSeries\r\n\r\nThe time series observations can be retrieved:\r\n\r\n\tdatastream.getTimeSeries({\r\n\t\tlimit: 100,\r\n\t\tskip:  100,\r\n\t\tstart: new Date(\"2013-01-01 00:00:00Z\"),\r\n\t\tend:   new Date(\"2013-05-28 00:00:00Z\"),\r\n\t\tdone:  function (seriesData) {\r\n\t\t\twindow.seriesData = seriesData;\r\n\t\t}\r\n\t});\r\n\r\n##### option: start\r\n\r\nAn optional Date object specifying the start limit of the time series. If left empty, will default to 24 hours ago.\r\n\r\n##### option: end\r\n\r\nAn optional Date object specifying the end limit of the time series. If left empty, will default to current date.\r\n\r\n#### done\r\n\r\nThis callback function will return the series data as the first parameter after it has been retrieved.\r\n\r\n#### limit\r\n\r\nThe number of records retrieved can be limited to this integer value. The Data Service starts counting at the newest time/value pair, so setting a limit of \"1\" would return the *latest* value in a time range, not the *earliest*.\r\n\r\nIf left empty, no limit will be applied to the number of records returned by the Data Service.\r\n\r\n#### skip\r\n\r\nSkip the latest *n* records returned from the Data Service (it sorts date *descending*). Can be used with `limit` to emulate pagination.\r\n\r\nIf left empty, no time series records will be skipped.\r\n\r\n##### Result\r\n\r\nThe `getTimeSeries` method will return an array of time series objects:\r\n\r\n\t[{\r\n\t\ttimestamp: 1356998400000,\r\n\t\tvalue: 3.88\r\n\t},\r\n\t{\r\n\t\ttimestamp: 1369699200000,\r\n\t\tvalue: 5.22\r\n\t}]\r\n\r\nThe returned objects contain timestamp and value properties. The timestamps correspond to the number of milliseconds since January 1, 1970, 00:00:00 UTC. They can be parsed with JavaScript's built-in Date library: `new Date(1356998400000)`.\r\n\r\nIf the `getTimeSeries` method is called multiple times (with the same or different options) then the results will be merged and can be retrieved with `datastream.seriesData()`.\r\n\r\n#### Datastream.seriesData\r\n\r\nRetrieve a sorted array of timeseries objects for a datastream, based on data already retrieved by `getTimeSeries()` operations. If `getTimeSeries()` has not yet been called, `seriesData()` will return an empty array.\r\n\r\n#### Data Service Customization\r\n\r\nThe Data Service URL is hard-coded into the library. Users can optionally override it:\r\n\r\n\tGeocens.DataService.setPath(\"http://dataservice.example.com/\");\r\n\r\nAfter override, all new requests will use the new Data Service path.\r\n\r\n### Chart Visualization\r\n\r\nThe GeoCENS JS API has an optional module for drawing simple charts. It requires the HighStock 1.3.2 or newer library to be installed. For a web page, include the `geocens-chart.js` file in a script tag, **after** the main `geocens.js` file.\r\n\r\n\t<script src=\"javascripts/highstock.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\r\n\t<script src=\"javascripts/geocens.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\r\n\t<script src=\"javascripts/geocens-chart.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\r\n\r\nUsing the chart API is intended to be an easier alternative to interfacing with HighStock yourself, because the options are pre-configured.\r\n\r\nA quick example with a Data Service datastream source:\r\n\r\n\t// Draw the chart after time series is returned\r\n\tvar drawChart = function(seriesData, datastream) {\r\n\t\tvar chart = $(\"#chart\").GeocensChart({\r\n\t\t\tdatastream: datastream\r\n\t\t});\r\n\t};\r\n\r\n\t// Retrieve the time series after datastream is returned\r\n\tvar getSeries = function(datastream) {\r\n\t\tdatastream.getTimeSeries({\r\n\t\t\tdone: drawChart\r\n\t\t});\r\n\t};\r\n\r\n\t// Retrieve the datastream\r\n\tGeocens.DataService.getDatastream({\r\n\t\tapi_key: \"your_32_character_api_key\",\r\n\t\tsensor_id: \"32_character_sensor_id\",\r\n\t\tdatastream_id: \"32_character_datastream_id\",\r\n\t\tdone: getSeries\r\n\t});\r\n\r\nIn the above example, the callback chain works in reverse. It first retrieves the datastream and passes it to the second function, which retrieves the time series and passes it to the first function. The first function then draws the chart with all the series data for the datastream.\r\n\r\nThis means that if multiple `getTimeSeries` requests are made, all the cached data for that datastream will be used for drawing the time series chart.\r\n\r\nUsing the chart API with OGC SOS observations is also short:\r\n\r\n\t// Draw the chart after time series is returned\r\n\tvar drawChart = function(seriesData, observation) {\r\n\t\tvar chart = $(\"#chart\").GeocensChart({\r\n\t\t\tobservation: observation\r\n\t\t});\r\n\t};\r\n\r\n\t// Retrieve the time series after observations is returned (note plural)\r\n\tvar getSeries = function(observations) {\r\n\t\tobservations[0].getTimeSeries({\r\n\t\t\tdone: drawChart\r\n\t\t});\r\n\t};\r\n\r\n\t// Retrieve the observations\r\n\tGeocens.SOS.getObservation({\r\n\t\tservice_url: \"http://www.example.com/sos\",\r\n\t\toffering: \"sos_offering\",\r\n\t\tproperty: \"sos_property\",\r\n\t\tdone: getSeries\r\n\t});\r\n\r\nThis example works in an identical manner to the Data Service example. As with the other example, in the case taht multiple `getTimeSeries` requests are made, all the cached data for that observation will be used for drawing the time series chart.\r\n\r\n##### option: observation\r\n\r\nPass in a OGC SOS observation object to the chart, which will draw the time series using the cached time series data. If specified with `datastream`, will take precedence.\r\n\r\n##### option: datastream\r\n\r\nPass in a Data Service datastream object to the chart, which will draw the time series using the cached time series data. If specified with `observation`, it will not be used.\r\n\r\n##### option: chart\r\n\r\nA JavaScript object with HighStock compatible configuration options. These options will be passed to the chart when it is created, overriding defaults set by the GeoCENS JS API chart module. Note that certain properties may not be overridden.\r\n\r\n### Map Visualization\r\n\r\nThe GeoCENS JS API has an optional module for mapping datastreams and/or observations. It requires the [Leaflet](http://leafletjs.com/) 0.6.0 or newer library to be installed. For a web page, include the `geocens-map.js` file in a script tag, **after** the main `geocens.js` file. It can be included with the `geocens-chart.js` module without conflict.\r\n\r\n\t<script src=\"javascripts/jquery.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\r\n\t<script src=\"javascripts/leaflet.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\r\n\t<script src=\"javascripts/geocens.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\r\n\t<script src=\"javascripts/geocens-map.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\r\n\r\nThe Map API makes it easy to draw map markers on a map without having to customize the markers and popups yourself. Getting started is as easy as [getting started with the Leaflet Library](http://leafletjs.com/examples/quick-start.html). An interactive demo is available in the `demo` directory.\r\n\r\n1. Include the Leaflet CSS files\r\n2. Include the Leaflet JS file\r\n3. Add a div element for the map\r\n4. Set the height on the div element\r\n5. Set up the map (see following code example)\r\n\r\n\t\t$(document).ready(function() {\r\n\t\t\tvar map = L.map('map', {\r\n\t\t\t\tcenter: [51.07993, -114.131802],\r\n\t\t\t\tzoom: 3\r\n\t\t\t});\r\n\r\n\t\t\tL.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {\r\n\t\t\t\tattribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\r\n\t\t\t}).addTo(map);\r\n\r\n\t\t\t// Add SOS Observations to the map\r\n\t\t\tvar mapObservations = function(observations) {\r\n\t\t\t\t// Returns a Leaflet FeatureGroup containing the markers.\r\n\t\t\t\tvar markerGroup = L.geocens(observations, {\r\n\t\t\t\t\t// Custom marker options.\r\n\t\t\t\t\t// See Leaflet Marker Options documentation.\r\n\t\t\t\t\tmarker: {\r\n\t\t\t\t\t\tclickable: true // note: setting clickable to false will disable popups\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t// Return custom HTML content for marker popups.\r\n\t\t\t\t\t// `datasource` refers to the datastream/observation for\r\n\t\t\t\t\t// the popup. `event` is the click event that activated\r\n\t\t\t\t\t// the popup, and `marker` is the one the user clicked.\r\n\t\t\t\t\tpopupContent: function(datasource, event, marker) {\r\n\t\t\t\t\t\treturn datasource.name();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tmarkerGroup.addTo(map);\r\n\t\t\t};\r\n\r\n\t\t\t// Retrieve the observations\r\n\t\t\tGeocens.SOS.getObservation({\r\n\t\t\t  service_url: \"http://app.geocens.ca:8171/sos\",\r\n\t\t\t  offering: \"Temperature\",\r\n\t\t\t  property: \"urn:ogc:def:property:noaa:ndbc:Water Temperature\",\r\n\t\t\t  done: mapObservations\r\n\t\t\t});\r\n\r\n\t\t}());\r\n\r\nIn the above example, a group of observations from an OGC SOS server are added to a map. Each marker on the map corresponds to a observation/procedure from the SOS, and displays a popup with the observed property/procedure id.\r\n\r\n#### L.geocens\r\n\r\nThis is a Leaflet function that is designed to add data from GeoCENS JS API data sources. It can be used on multiple input types:\r\n\r\n\t// A single OGC SOS observation\r\n\tL.geocens(observation);\r\n\r\n\t// An array of OGC SOS observations\r\n\tL.geocens(observations);\r\n\r\n\t// A single GeoCENS Data Service datastream\r\n\tL.geocens(datastream);\r\n\r\n\t// An array of GeoCENS Data Service datastreams\r\n\tL.geocens(datastreams);\r\n\r\nAll instances will return a Leaflet FeatureGroup.\r\n\r\nThe function also supports an options input, allowing the markers and popups to be customized. Modifying these will override the defaults.\r\n\r\n\tL.geocens(observations, {\r\n\t\tmarker: {\r\n\t\t\tclickable: true\r\n\t\t},\r\n\r\n\t\tpopupContent: function(datasource, event, marker) {\r\n\t\t\treturn datasource.name();\r\n\t\t}\r\n\t});\r\n\r\n##### option: marker\r\n\r\nCustom Leaflet Marker options, applied to every marker generated from the input data. See the [Leaflet Marker option documentation](http://leafletjs.com/reference.html#marker-options) for options.\r\n\r\nBy default, it will apply no customization to the markers and they will appear as the Leaflet default markers.\r\n\r\n##### option: popup\r\n\r\nCustom Leaflet Popup options, applied to the popup that is displayed when a marker is clicked. See the [Leaflet Marker option documentation](http://leafletjs.com/reference.html#popup-options) for options.\r\n\r\n##### option: popupContent\r\n\r\nCustom content to be inserted into popups. Whenever a user clicks on a marker, it will trigger this function to determine what HTML content will be displayed in the popup for the marker. The function will return the `datasource`, `event` and `marker`. The `datasource` is the observation or datastream for the marker; it can be queried using their respective APIs. The `event` is the [Leaflet click event](http://leafletjs.com/reference.html#mouse-event) for the popup. The `marker` is the [Leaflet marker](http://leafletjs.com/reference.html#marker) the user clicked on.\r\n\r\nNote that if click events are disabled for the marker (in the marker options), then the popup will not be displayed.\r\n\r\n## Running Test\r\n\r\nThere is a test suite for ensuring the JS API meets its requirements. The JS API is build with Behaviour Driven Development ([BDD](http://dannorth.net/introducing-bdd/)), which focuses on defining *requirements* before any code is written. This keeps new code clean and concise, only enough to satisfy the new behaviour.\r\n\r\nThe tests can be run in a web browser by opening the `test/index.html` file. They are based on [Qunit](http://qunitjs.com/).\r\n\r\nAlternatively, the tests can be run from the command line if Node and NPM is installed.\r\n\r\n\t$ npm install -g grunt-cli\r\n\t$ npm install\r\n\t$ grunt qunit\r\n\r\nSee `Gruntfile.js` for more tasks that can be run from the command line.\r\n\r\n## License\r\n\r\n2013, James Badger, Geo Sensor Web Lab, All Rights Reserved.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}